% @(#) $Id$

\section{Tutorial and Cookbook}

The folllowing examples demonstrate how to use Mapyrus.  Each example is also
included as a file in the \texttt{userdoc} subdirectory.  All example files
have file suffix \texttt{.mapyrus}.  This suffix is not required but makes
identification of files that are to be interpreted by Mapyrus easier.

If the Ghostscript program or a printer is not available, then change the
\texttt{eps} arguments in \texttt{newpage} commands in examples to \texttt{png}
to create the output files in PNG image format and view the output files in a
web browser.

\subsection{First Steps}

Enter the following lines into a text file named \texttt{first.mapyrus}.

\verbatiminput{tutorialfirst1.mapyrus}

Each line in the file is a command for Mapyrus.  The first line sets output to
a 30mm square Encapsulated PostScript format file named
\texttt{tutorialfirst1.eps} with the \texttt{newpage} command.  The second and
third lines set the color for drawing to black, with lines drawn 4 millimetres
wide with rounded ends and corners.  The fourth and fifth lines define a path
on the page giving coordinates in millimetres.  The sixth line is a
\texttt{stroke} command to draw the path just defined onto the page using the
current color and line style.

Open a terminal window and run Mapyrus using following command to execute the
commands in the file \texttt{first.mapyrus}
(\textit{install-dir} is the directory
in which Mapyrus is installed).

\begin{alltt}
java -classpath \textit{install-dir}/mapyrus.jar org.mapyrus.Mapyrus first.mapyrus
\end{alltt}

When Mapyrus reaches the end of the file \texttt{first.mapyrus}
the output file \texttt{tutorialfirst1.eps} is saved and Mapyrus exits.
When the PostScript file is then printed, it appears as in
Figure \ref{tutorialfirst1}.

\begin{figure}[htb]
\includegraphics{tutorialfirst1.eps}
\caption{First Step}
\label{tutorialfirst1}
\end{figure}


Change the file \texttt{first.mapyrus} to contain the following lines.

\verbatiminput{tutorialfirst2.mapyrus}

In this example, color is set as a hex value instead of a name,
a rectangle is defined with the \texttt{box} command
and the \texttt{fill} command is used to
flood fill it.
The characters on lines following a hash (\texttt{\#}) character that
is not part of a string literal are ignored by Mapyrus.
Figure \ref{tutorialfirst2} shows the output of these commands.

\begin{figure}[htb]
\includegraphics{tutorialfirst2.eps}
\caption{Second Step}
\label{tutorialfirst2}
\end{figure}

Change the file \texttt{first.mapyrus} to contain the following lines.

\verbatiminput{tutorialfirst3.mapyrus}

This example demonstrates drawing circular arcs,
giving the direction (a positive value for clockwise and a negative
value for anti-clockwise), center point and end point and
yet another way of defining color.
After being filled, the path remains and is used again to draw the outline
of the shape.
To clear the path before drawing another shape the
\texttt{clearpath}
command is used.
The second shape contains an island (or hole).  When a shape is
self-intersecting or contains islands, the winding rule is
used for determining which areas get filled.
The output of these commands is shown in Figure \ref{tutorialfirst3}.

\begin{figure}[htb]
\includegraphics{tutorialfirst3.eps}
\caption{Third Step}
\label{tutorialfirst3}
\end{figure}

\subsection{Using Variables}

Use variables and conditional tests to vary the appearance
of the display.
Use loops to display similar symbols repeatedly.
Variables named \texttt{c1} and \texttt{c2} are used in the
following example.  The variable
\texttt{Mapyrus.page.width}
is set by Mapyrus automatically.
The output of this example is shown in Figure \ref{tutorialvar1}.

\verbatiminput{tutorialvar1.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialvar1.eps}
\caption{Variables And Loops}
\label{tutorialvar1}
\end{figure}

The second example demonstrates the use of the
\texttt{length} and \texttt{substr}
functions
and stepping through a string one element at a time.
The output of this example is shown in Figure \ref{tutorialvar2}.

\verbatiminput{tutorialvar2.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialvar2.eps}
\caption{Variables And Functions}
\label{tutorialvar2}
\end{figure}


\subsection{Building Procedures}

Store frequently used sequences of commands in a procedure.
A procedure has a unique name, takes a fixed number of arguments and
may be called from any place where a command is expected.

Private variables in a procedure are defined with the 
\texttt{local} command.

When a procedure is called, the graphics state
is saved (see page \pageref{graphicsstate}),
the commands for the procedure are executed and then the
graphics state is restored before returning.

The following example shows a simple procedure named \texttt{trail}.
The output of this example is shown in Figure \ref{tutorialprocedures1}.

\verbatiminput{tutorialprocedures1.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialprocedures1.eps}
\caption{Calling Procedures}
\label{tutorialprocedures1}
\end{figure}

If the current path contains only points added with \texttt{move}
commands when a procedure is called, then the
procedure is called once for each point with the origin
moved to that point.  This permits several symbols to be drawn
easily and is demonstrated in the following example.  The 
output of this example is shown in Figure \ref{tutorialprocedures2}.

\verbatiminput{tutorialprocedures2.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialprocedures2.eps}
\caption{Procedures And Move Points}
\label{tutorialprocedures2}
\end{figure}


Put frequently used procedures in a separate file and use an
\texttt{include}
line to include it in other files.  When this is done for the
previous example, the procudure is put in a file.

\verbatiminput{tutorialprocedures3.mapyrus}

and the file containing the commands to execute

\verbatiminput{tutorialprocedures4.mapyrus}

\subsection{Displaying Lines}

Simple solid line styles or dashed line styles
are set with the
\texttt{linestyle} command.  More complex line styles are built using
symbols repeated along a line or combinations of linestyles, plotted
on top of each other.

To draw a line with repeated symbols, use the
\texttt{samplepath}
command to replace the path with evenly spaced sample points and
then call a procedure to draw a symbol at each sample point.
The following example demonstrates this.

\verbatiminput{tutoriallines1.mapyrus}

\begin{figure}[htb]
\includegraphics{tutoriallines1.eps}
\caption{Repeating Symbols Along A Line}
\label{tutoriallines1}
\end{figure}

The next example demonstrates
combining solid and dashed linestyles.
For best results display all lines with a solid linestyle,
then display all lines again with a dashed linestyle.

\verbatiminput{tutoriallines2.mapyrus}

\begin{figure}[htb]
\includegraphics{tutoriallines2.eps}
\caption{Combining Solid And Dashed Linestyles}
\label{tutoriallines2}
\end{figure}

The following example demonstrates combining thick and
thin linestyles and symbols at sampled points.
For best results display all lines with a thick linestyle,
then display all lines again with a thin linestyle.

\verbatiminput{tutoriallines3.mapyrus}

\begin{figure}[htb]
\includegraphics{tutoriallines3.eps}
\caption{Combining Several Linestyles}
\label{tutoriallines3}
\end{figure}

The following examples demonstrate creating sample points
from the path to generate further line styles.

\verbatiminput{tutoriallines4.mapyrus}

\begin{figure}[htb]
\includegraphics{tutoriallines4.eps}
\caption{Linestyle Using Begin And End Points}
\label{tutoriallines4}
\end{figure}

\verbatiminput{tutoriallines5.mapyrus}

\begin{figure}[htb]
\includegraphics{tutoriallines5.eps}
\caption{Linestyle Using Sample Points}
\label{tutoriallines5}
\end{figure}

\subsection{Displaying Polygons}

Polygon outlines are drawn with the \texttt{stroke}
command and filled with the \texttt{fill} command.
To draw repeated stripes (also known as hatching) through
the polygon, use the \texttt{clip}
command to limit the area displayed to inside the polygon,
then the \texttt{stripepath}
command to replace the path with evenly spaced stripes and
then draw each stripe.  The following example demonstrates this,
with the output shown in Figure \ref{tutorialpolygons1}.

\verbatiminput{tutorialpolygons1.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialpolygons1.eps}
\caption{Hatching Polygons}
\label{tutorialpolygons1}
\end{figure}

To fill a polygon with cross-hatching use procedures to
draw each set of hatch lines at different angles.  Two procedures
are used so that modifying the current path with the
\texttt{stripepath}
command is isolated in one procedure and the original path
remains unmodified in the calling procedure.
This is demonstrated in the following example, with the output
shown in Figure \ref{tutorialpolygons2}.

\verbatiminput{tutorialpolygons2.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialpolygons2.eps}
\caption{Cross-Hatching Polygons}
\label{tutorialpolygons2}
\end{figure}

Use the \texttt{stripepath} and \texttt{samplepath}
commands in combination to generate a grid of points through the
polygon, then call a procedure to draw a symbol at each point.
This is demonstrated in the following example, with the output
shown in Figure \ref{tutorialpolygons3}.

\verbatiminput{tutorialpolygons3.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialpolygons3.eps}
\caption{Displaying Points in Polygons}
\label{tutorialpolygons3}
\end{figure}

To display a border around the inside of the polygon
use the \texttt{clip}
command to limit the area displayed to inside the polygon
and then draw the outline with a thick linestyle.
The following example demonstrates this, with the output shown
in Figure \ref{tutorialpolygons4}.
Give the argument \texttt{outside}
to the \texttt{clip} command
to display a border around the outside of a polygon instead.

\verbatiminput{tutorialpolygons4.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialpolygons4.eps}
\caption{Displaying Polygon Borders}
\label{tutorialpolygons4}
\end{figure}

\subsection{Displaying Labels}

Labels are displayed using the \texttt{move}
command to define one or more points for labelling, followed by a
\texttt{label} command.  The font and justification for labels
are set with the \texttt{font} and \texttt{justify} commands.
Setting fonts, justification and displaying multiple lines
are demonstrated in the following example, with output
shown in Figure \ref{tutoriallabels1}.

\verbatiminput{tutoriallabels1.mapyrus}

\begin{figure}[htb]
\includegraphics{tutoriallabels1.eps}
\caption{Displaying Labels}
\label{tutoriallabels1}
\end{figure}

Labels are displayed horizontally.  Rotate the axes with the \texttt{rotate}
command before setting the font to display labels at an angle.
This is demonstrated in the following example,
with output shown in Figure \ref{tutoriallabels2}.

\verbatiminput{tutoriallabels2.mapyrus}

\begin{figure}[htb]
\includegraphics{tutoriallabels2.eps}
\caption{Rotated Labels}
\label{tutoriallabels2}
\end{figure}

Several methods are available for changing the appearance of labels.

Drawing a label with a small offset from its original position in a different
color highlights a label.

The \texttt{stringwidth} function (see Table \ref{functions}
on page \pageref{functions}) calculates the
width of a label.  This value is used to underline a label, draw a box
surrounding a label, or to join several labels together on a single line.

These techniques are demonstrated in the following example,
with output shown in Figure \ref{tutoriallabels3}.

\verbatiminput{tutoriallabels3.mapyrus}

\begin{figure}[htb]
\includegraphics{tutoriallabels3.eps}
\caption{Highlighted Labels}
\label{tutoriallabels3}
\end{figure}

The \texttt{sinkhole} command is used determine a position
for a label in a polygon.  This command
replaces the current path defining a polygon with a single point in
the middle of the polygon.  This is demonstrated in the following
example, with output shown in Figure \ref{tutorialsinkhole}.

\verbatiminput{tutorialsinkhole.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialsinkhole.eps}
\caption{Labelling Polygons}
\label{tutorialsinkhole}
\end{figure}

\subsection{Displaying Data Stored In Text Files}

The simplest source of data is a text file, with one record per line.  The
filename and type of dataset to read is given in a \texttt{dataset} command.
Then a \texttt{fetch} command is used in a loop to read each record
and assign a variable with a value of each field.
Fields are assigned to variables
\texttt{\$1}, \texttt{\$2}, \texttt{\$3}, \dots and the whole record is
assigned to variable \texttt{\$0}.

The following example demonstrates reading the text file shown in Figure
\ref{tutorialdatasets1txt} and displaying the
geographic data that it contains.  The output of this example is shown in
Figure \ref{tutorialdatasets1}.

\begin{figure}[htb]
\verbatiminput{tutorialdatasets1.txt}
\caption{Text File tutorialdatasets1.txt}
\label{tutorialdatasets1txt}
\end{figure}

\verbatiminput{tutorialdatasets1.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialdatasets1.eps}
\caption{Displaying Contents Of A Text File}
\label{tutorialdatasets1}
\end{figure}

Coordinates in GIS datasets are often stored
in a world coordinate system such as
Universal Transverse Mercator.  To transform these coordinates to millimetre
coordinates on the page use the \texttt{worlds} command.  This sets a
transformation to map a range of world coordinates onto the whole page.  All
coordinates given for later \texttt{addpath}, \texttt{move}, \texttt{arc},
\texttt{box} and
\texttt{draw} commands are converted from world coordinate to page coordinates
through this transformation.

Export files of GIS datasets are also read as text files.  A loop and counter
are used to read all coordinates making up lines and polygons.

The following example demonstrates setting a world coordinate system and then
reading and displaying the GenaMap GIS ZF19 format export file shown in Figure
\ref{streetsEE} containing line
features.  The tag of each line is used as a street name label.
The output is shown in Figure \ref{tutorialdatasets2}.

\begin{figure}[htb]
\verbatiminput{streets.EE}
\caption{GIS Export File streets.EE}
\label{streetsEE}
\end{figure}

\verbatiminput{tutorialdatasets2.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialdatasets2.eps}
\caption{Displaying GIS Export Files}
\label{tutorialdatasets2}
\end{figure}

\subsection{Displaying Data Stored In Shape Files}

Reading data from an ESRI Shape file format is similar to reading a text file.
A Shape file defines a bounding rectangle so the internal variables
\texttt{Mapyrus.dataset.min.x}, \texttt{Mapyrus.dataset.min.y},
\texttt{Mapyrus.dataset.max.x}, and \texttt{Mapyrus.dataset.max.y} are
available to set world coordinates to the bounding rectangle of the dataset.

An ESRI Shape file also defines field names.  Fields fetched with the
\texttt{fetch} command are assigned to variables with the same name as the
field.  The geometry for each record is assigned to a variable named
\texttt{GEOMETRY} and is added to the current path with the \texttt{addpath}
command.

The following example demonstrates reading an ESRI Shape file containing points
and attribute fields named \texttt{HOTELNAME} and \texttt{STARRATING}.  The
attribute fields are used as labels and to control the appearance of the
symbols.

\verbatiminput{tutorialdatasets3.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialdatasets3.eps}
\caption{Displaying ESRI Shape Files}
\label{tutorialdatasets3}
\end{figure}

\subsection{Displaying Data Stored In A Database}

Data is read from a relational database using
the Java JDBC interface and a JDBC driver provided
as part of the database.
Each field in a database table has a name.
Fields fetched with the
\texttt{fetch}
command are assigned to variables with the same name as the field.
In the following example three fields are fetched from each
row and assigned to variables named
\texttt{longitude}, \texttt{latitude} and \texttt{assetcode}.

An SQL where clause is used to limit data read from
the database to inside the area of interest.

\verbatiminput{tutorialdatasets4.mapyrus}

For databases supporting the \textit{OpenGIS Simple Features Specification For
SQL}, convert fields containing OGC WKT geometry strings
into geometry using the \texttt{parsewkt}
function.  The geometry is then added to the current
path directly with an \texttt{addpath} command.  The
following example demonstrates fetching a geometry field named \texttt{geom}
from the database and displaying it.

\verbatiminput{tutorialdatasets5.mapyrus}

\subsection{Display Performance}

The following techniques help improve the display speed of large datasets.

Check the internal variable \texttt{Mapyrus.worlds.scale} before displaying a
large, detailed dataset.  If the scale is too high then the details will not be
legible so skip display of the detailed part of the dataset.  For example,
display all streets when zoomed in, but only highways when zoomed out.

Store two copies of the same data.  One at high resolution and one at low
resolution.  Select the dataset with the resolution closest to the current
display scale.

For dense data, with many points very close to each other, skip every second
piece of data in the dataset using two \texttt{fetch} commands together.  When
the dataset is in a database this is more efficiently done by ignoring odd
numbered rows using an SQL statement like:

\begin{verbatim}
select X, Y, Freq from SCATTER where MOD(rowid, 2) = 0
\end{verbatim}

Set an upper limit on the number of rows fetched or the time for display by
checking the internal variables \texttt{Mapyrus.fetch.count} and
\texttt{Mapyrus.timer} in a loop and ending when the limit is exceeded.

\subsection{Displaying A Legend}

A cartographic rule is that a map display must include a legend.  The
\texttt{key} command is used to save each entry to be include in a legend and
the \texttt{legend} command displays a legend.

A \texttt{key} command in a procedure defines a legend entry.  Mapyrus saves
each legend entry encountered whilst executing commands.  Each legend entry has
a description label and a type, defining whether the entry appears as a point,
line or box in the legend.

When display of all data is complete, points for legend entries are defined
with \texttt{move} commands and the \texttt{legend} command is used to display
each legend entry.  Each legend entry is automatically displayed by calling the
procedure in which it was defined.

If insufficient \texttt{move} points are defined then some legend entries
remain undisplayed.

Display the legend in a separate image file to prevent overwriting the map.

This is demonstrated in the following example.
The two output files are shown in Figure \ref{tutoriallegend1}.
Note that the legend entry for the procedure \texttt{road} is
not included in the legend because this procedure is not
executed in the example.

\verbatiminput{tutoriallegend1.mapyrus}

\begin{figure}[htb]
\includegraphics{tutoriallegend1.eps}
\includegraphics{tutoriallegend1legend.eps}
\caption{Displaying A Legend}
\label{tutoriallegend1}
\end{figure}

To display each legend entry in a separate file use a loop, checking the
internal variable \texttt{Mapyrus.key.count} to find how many legend entries
remain to be displayed.

In each loop iteration, create a new output file, set a single \texttt{move}
point and then display a single legend entry with a \texttt{legend} command.
Continue until all legend entries are displayed.

This is demonstrated in the following example, with each separate legend entry
PostScript file inserted into a table.  The output is shown in Figure
\ref{tutoriallegend2}.  This approach is also useful for inserting legend
entries into an HTML table.

\verbatiminput{tutoriallegend2.mapyrus}

\begin{figure}[htb]
\includegraphics{tutoriallegend2.eps}

\begin{tabular}{|c|}
\hline
Individual Legend PostScript Files \\
\hline
\includegraphics{tutoriallegend2legend1.eps} \\
\hline
\includegraphics{tutoriallegend2legend2.eps} \\
\hline
\includegraphics{tutoriallegend2legend3.eps} \\
\hline
\includegraphics{tutoriallegend2legend4.eps} \\
\hline
\end{tabular}

\caption{Displaying Legend Entries Individually}
\label{tutoriallegend2}
\end{figure}

\subsection{Using Attributes To Control Display}

Use attributes of geographic data to control
color, size, shape, labelling, highlighting and alignment of symbols, lines
and polygons.
Use \texttt{if}-\texttt{then}-\texttt{endif}
statements to display different classes of data
differently.  For example, display private, local, and major roads
with different types of lines.

To display data with a known range of attribute values in different
colors based on the attribute value, define colors for minimum and
maximum values and calculate the color for each point or polygon
using linear interpolation.  This is demonstrated in the following
example by passing a \texttt{reading} attribute value for each point
that is displayed.  The output is shown in Figure \ref{tutorialattribute1}.
A legend is also created to show how the coloring works.

\verbatiminput{tutorialattribute1.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialattribute1.eps}
\includegraphics{tutorialattribute1legend.eps}
\caption{Using Attributes}
\label{tutorialattribute1}
\end{figure}

Further examples are varying the size of a symbol depending on a
population or measurement value, varying line width depending on
traffic between two points, or varying the symbols plotted inside
polygons depending on soil or rock type.

To display values of several attributes at point locations, draw a
piechart or histogram at each point.

\subsection{Displaying A Scalebar}
\label{tutorialscalebar}

Another cartographic rule is that a map display must include a scalebar.  The
following example creates two PostScript files using the internal variable
\texttt{Mapyrus.worlds.scale} to add a scale bar to the lower-left corner
of each map display.

The included file \texttt{scalebar.mapyrus} (available in the \texttt{userdoc}
subdirectory) defines a procedure named \texttt{scalebar}.  This procedure
performs the task of displaying the scalebar.  Include this file and call the
\texttt{scalebar} procedure whenever a scalebar is required for a map display.

Output from the example is shown in Figure \ref{tutorialscalebar1}.

An alternative approach for displaying scalebars is to save the scale value in
a variable, use the \texttt{newpage} command to create a new output file and
display the scalebar in a separate file from the map.

\verbatiminput{tutorialscalebar1.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialscalebar1.eps}
\includegraphics{tutorialscalebar2.eps}
\caption{Displaying A Scalebar}
\label{tutorialscalebar1}
\end{figure}

\subsection{Displaying Piecharts}

Piecharts are used to represent relative values of several attributes at
different locations.  For example, production levels or voting patterns.  The
following example demonstrates this using fixed data values
In a real application this information is read from a
database or GIS dataset.

The included file \texttt{piechart.mapyrus} (available in the \texttt{userdoc}
subdirectory) defines a procedure named \texttt{piechart}.  This procedure
performs the task of displaying a piechart.  Include this file and call the
\texttt{piechart} procedure whenever piecharts are to be displayed.

The output is shown in Figure \ref{tutorialpiechart1}.

\verbatiminput{tutorialpiechart1.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialpiechart1.eps}
\caption{Displaying Piecharts}
\label{tutorialpiechart1}
\end{figure}

\subsection{Random Effects}

Random effects are generated using the \texttt{random}
function and help give a map a less mechanical appearance.
The following example demonstrates setting size and color randomly.
The output is shown in Figure \ref{tutorialrand1}.

\verbatiminput{tutorialrand1.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialrand1.eps}
\caption{Random Size And Color}
\label{tutorialrand1}
\end{figure}

The next example demonstrates setting rotation randomly, with output shown in
Figure \ref{tutorialrand2}.

\verbatiminput{tutorialrand2.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialrand2.eps}
\caption{Random Rotation}
\label{tutorialrand2}
\end{figure}

The next example demonstrates setting position randomly for polygon fill, with
output shown in Figure \ref{tutorialrand3}.

\verbatiminput{tutorialrand3.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialrand3.eps}
\caption{Random Position}
\label{tutorialrand3}
\end{figure}

\subsection{Shadow Effects}
\label{tutorialshadow}

To highlight polygons with a shadow, draw the outline of the polygon, use a
\texttt{clip "outside"}
command to prevent the interior of the polygon being drawn,
then repeatedly use the \texttt{shiftpath} command to move the polygon a small
distance from its original position, drawing it each time.  This is
demonstrated in the following example, with output shown in Figure
\ref{tutorialshadow1}.  Change the sign of the shift values in the
\texttt{shiftpath} command to draw the highlight on a different side of the
polygon.

\verbatiminput{tutorialshadow1.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialshadow1.eps}
\caption{Shadow Effects}
\label{tutorialshadow1}
\end{figure}

\subsection{Displaying Image Icons}
\label{icons}

Display color image icons and clip-art using the \texttt{icon} command.
Icons are scaled and rotated to any size and rotation angle.
Displaying icons is demonstrated in the following example
with output shown in Figure \ref{tutorialicon1}.

\verbatiminput{tutorialicon1.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialicon1.eps}
\caption{Icon Display}
\label{tutorialicon1}
\end{figure}

Combine the \texttt{icon} command with
\texttt{stripepath} and
\texttt{samplepath} commands to
repeat the icon in a tile pattern inside a polygon.
This is demonstrated in the following example
with output shown in Figure \ref{tutorialicon2}.

\verbatiminput{tutorialicon2.mapyrus}

\begin{figure}[htb]
\includegraphics{tutorialicon2.eps}
\caption{Icon Fill Pattern}
\label{tutorialicon2}
\end{figure}


\subsection{Generating Portable Document Format (PDF) Output}
\label{pdf}

Portable Document Format (PDF) files are created by converting PostScript
output from Mapyrus to PDF using the \texttt{ps2pdf} utility program, part of
the GhostScript\footnote{Available from http://www.ghostscript.com} software.

The pipe option of the \texttt{newpage} command is used to pipe PostScript
output from Mapyrus through \texttt{ps2pdf} and into a PDF file.  To create
a PDF file with A4 page size using the following command:

\begin{verbatim}
newpage "ps", "| ps2pdf - myfile.pdf", 210, 297, 300
\end{verbatim}

\subsection{Using PostScript Fonts In PostScript Output}
\label{psfonts}

PostScript printers and the Ghostscript program
understand a limited number of fonts,
normally only 35 basic fonts including
AvantGarde,
Bookman,
Courier,
Helvetica,
NewCenturySchlbk,
Palatino,
Symbol,
Times-Roman,
ZapfChancery,
ZapfDingbats
and the bold
and oblique (italic) variations of these fonts.

When a PostScript printer prints a file containing an unknown font,
a substitute font is used.

To make a font known to the printer, include the definition of
the font in the PostScript file being printed.

A PostScript Type 1 font is defined in two files with suffixes
\texttt{.pfa} and \texttt{.afm}.  PostScript
font definition files are included in a PostScript file created
by Mapyrus using the
\textit{extras} \texttt{pfafiles} and \texttt{afmfiles}
options to the \texttt{newpage} command.
Include filenames of PostScript font definition files for all fonts to be used
in the page that are not known by the printer.

PostScript Type 1 font definition files are text files and
the first line of the file with \texttt{.pfa} suffix
contains the name of the font defined in the file.

To convert a True Type Font file to a PostScript Type 1 font use the
ttf2pt1\footnote{Available from http://ttf2pt1.sourceforge.net} program.  The
following command converts the font in the file \texttt{BEANTOWN.TTF} to a
PostScript Type 1 font in files
\texttt{BEANTOWN.pfa} and
\texttt{BEANTOWN.afm}.

\begin{verbatim}
ttf2pt1 -e BEANTOWN.TTF BEANTOWN
\end{verbatim}

\subsection{Using TrueType Fonts In Output to Image Formats}
\label{ttffonts}

For output to image formats, TrueType format fonts are used.

MicroSoft Windows and Macintosh operating systems support TrueType
fonts directly and all installed TrueType fonts are available
for use in the \texttt{font} command.
Additional TrueType fonts are installed using operating system commands.

A TrueType font is defined in a binary file with suffix
\texttt{.ttf}.
The name of a TrueType font normally does not match the filename exactly.
MicroSoft Windows Explorer and font display programs show the name of
a font contained in a TrueType font file.

Other operating systems do not support TrueType fonts.  To use TrueType fonts
on other operating systems using the \textit{extras} \texttt{ttffiles} option
to the \texttt{newpage} command.  Include filenames of TrueType font definition
files to be used in the page.

\subsection{Using Mapyrus In A Java Application}
\label{javaapi}

To use Mapyrus in a Java application, create objects of the class
\texttt{org.mapyrus.Mapyrus}.  Each Mapyrus object is an interpreter
and parses and executes
lists of commands passed to its \texttt{interpret()} method.

A \texttt{setPage()} method is provided for an application to set
an \texttt{java.awt.image.BufferedImage} as the initial output page.
This enables Mapyrus to draw into a buffer that the application
later displays in a window.  Use several transparent buffered images, one for
each layer of data so that an application can turn layers on and
off or re-order layers without calling Mapyrus.

Both methods are demonstrated in the following sample Java code.

\begin{verbatim}
String []commands1 =
{
  "newpage 'ps', 'test.ps', 210, 297",
  "move 0, 0",
  "draw 20, 20, 40, 20",
  "stroke"
};
Mapyrus m1 = new Mapyrus();
m1.interpret(commands1, System.out);
m1.close();

String []commands2 =
{
  "dataset 'shapefile', 'coastline.shp', ''",
  "worlds Mapyrus.dataset.min.x, Mapyrus.dataset.min.y, \",
  "  Mapyrus.dataset.max.x, Mapyrus.dataset.max.y",
  "while Mapyrus.fetch.more",
  "do",
  "  fetch",
  "  clearpath",
  "  addpath GEOMETRY",
  "  stroke",
  "done"
};
BufferedImage bi = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
Mapyrus m2 = new Mapyrus();
m2.setPage(bi, "");
m2.interpret(commands2, System.out);
// Copy buffered image to screen.
g.drawImage(bi, 0, 0, null);
\end{verbatim}

\subsection{Setting Up Mapyrus As An HTTP Server}
\label{tutorialhttpserver}

Enter the following lines into a text file named
\texttt{tutorialhttpserver1.mapyrus}.

\verbatiminput{tutorialhttpserver1.mapyrus}

Copy the file \texttt{coastline.shp} from the \texttt{userdoc}
subdirectory in the
Mapyrus installation into the same directory as the file
\texttt{tutorialhttpserver1.mapyrus}.  In a terminal window, change to the
directory containing the two files and start Mapyrus as an HTTP server on port
8410 with the following command
(where \textit{install-dir} is the directory in which Mapyrus is installed).

\begin{alltt}
java -classpath \textit{install-dir}/mapyrus.jar org.mapyrus.Mapyrus -s 8410
\end{alltt}

Then enter the URL \texttt{http://localhost:8410/tutorialhttpserver1.mapyrus} in a
web browser.  Mapyrus receives the request, executes the commands in the file
\texttt{tutorialhttpserver1.mapyrus} and returns the PNG image that is written to
standard output to the web browser.

\subsection{Passing Variables To Mapyrus HTTP Server Through URLs}

To vary the display that is created by the Mapyrus HTTP Server, include
variables in the URL.  For example,

\begin{verbatim}
http://localhost:8410/tutorialurl.mapyrus?x1=11&y1=48&x2=12&y2=49&labels=off
\end{verbatim}

The variables \texttt{x1}, \texttt{y1}, \texttt{x2}, \texttt{y2}
and \texttt{labels} are automatically set in Mapyrus with the values
passed in the URL before interpreting
the commands in the file \texttt{tutorialurl.mapyrus}.

For applications that manage state
and provide a graphical user interface (such as clients written in
Java or Visual Basic), use this method for returning data to the
application.

\subsection{Returning HTML Pages From Mapyrus HTTP Server}

An application for web browsers is based on HTML pages.
Generate HTML in Mapyrus and return it with \texttt{print} commands.
Generate temporary images for the HTML page with
unique filenames using the
\texttt{tempname}
function and return references to the images in the HTML.

The example file \texttt{tutorialhtmlpage1.mapyrus} demonstrates
this, displaying ESRI Shape file
\texttt{coastline.shp}
and text file
\texttt{aust\_temperatures.dat}
and using an HTML form to allow
the user to change the map display.
These three files are stored in the \texttt{userdoc} subdirectory
in a Mapyrus installation.
In a terminal window change to this directory and
start Mapyrus with the HTTP Server option, as described in section
\ref{tutorialhttpserver}.
Then enter the following URL in a web browser.

\begin{verbatim}
http://localhost:8410/tutorialhtmlpage1.mapyrus
\end{verbatim}

To simplify editing of HTML pages for an application, setup
template HTML pages with placeholders for the information that
Mapyrus provides.  This enables the HTML interface to be designed
independently from Mapyrus.

In Mapyrus, return the HTML pages with the placeholders
replaced by real values using the
\texttt{replace}
function.  The Mapyrus commands in the file \texttt{tutorialhtmlpage2.mapyrus}
and the template HTML file \texttt{tutorialhtmlpage2.txt}
demonstrate this.  Both files are found in the
\texttt{userdoc} subdirectory.

\subsection{Returning Additional Information From Mapyrus HTTP Server}

Further ideas for building a complete HTML application are:

\begin{itemize}
\item
For datasets covering a wide area generate two images for
each HTML page.  Create a detailed map display and an overview map display
with a box showing the position of the detailed map in the dataset.

\item
Generate an image containing a scalebar
and include this in the HTML page.  See section \ref{tutorialscalebar}.

\item
Restrict datasets to a limited scale range by checking the
internal variable
\texttt{Mapyrus.worlds.scale} before displaying a dataset.
\end{itemize}

\subsection{Using Imagemaps With Mapyrus HTTP Server}

When Mapyrus receives a URL requested by the user
clicking on an HTML imagemap, the
internal variables
\texttt{Mapyrus.imagemap.x} and
\texttt{Mapyrus.imagemap.y} are automatically set with the pixel position
clicked in the image (with origin in top-left corner of the image).
Use these variables to re-center, or zoom the display to the
point clicked in the imagemap.

The following example demonstrates
using these variables to generate a new image, based on the
position clicked in the imagemap.

\verbatiminput{tutorialimagemap1.mapyrus}

\subsection{Combining Mapyrus With Other Software}

To combine Mapyrus with other software use the following
techniques.

Pass parameters from calling environment to Mapyrus using the Java
\texttt{-D} option.

To use Mapyrus in a pipeline of commands,
give \texttt{-} as output file in the
\texttt{newpage}
command to write image to standard output.

Use Mapyrus in combination with the freely available software
Netpbm\footnote{Available from http://netpbm.sourceforge.net} and
Ghostscript\footnote{Available from http://www.ghostscript.com} to post-process
image output and convert images and PostScript output to other formats.

The following examples demonstrate these methods.

\begin{verbatim}
java -DDATADIR=$DATADIR -DNameidx=Q7B80L -classpath mapyrus.jar \
  org.mapyrus.Mapyrus mycommands.mapyrus | pngtopnm | ppmtopgm | \
  pgmtopbm | pbmtoascii -2x4
\end{verbatim}

\begin{verbatim}
java -classpath mapyrus.jar org.mapyrus.Mapyrus \
  $HOME/common.mapyrus mycommands.mapyrus > myfile.ps
gs -sDEVICE=faxg3 -sOutputFile=myfile.fax \
  -TextAlphaBits=4 myfile.ps
\end{verbatim}

A Java Virtual Machine takes more than one second to start on many computers.
For applications that must start Mapyrus many times to perform short tasks,
start Mapyrus as an HTTP server and make HTTP requests instead so that
startup time is eliminated.
Most programming languages include a method of making HTTP requests.
From Perl use the libwww-perl modules.

Use lynx\footnote{Available from http://www.lynx.browser.org} or
w3m\footnote{Available from http://w3m.sourceforge.net}
from languages without the ability to make
HTTP requests.  For example,

\begin{verbatim}
w3m -dump_source \
  http://localhost:8410/wsrv.mapyrus?plz=81673&zoomlevel=3 > m.png
\end{verbatim}

\subsection{Building Mapyrus From Source}

To build Mapyrus from source code, the following development tools
are required:

\begin{itemize}
\item
Ant build tool.
\item
Java 2 SDK 1.4, or higher.
\item
\LaTeX
\end{itemize}

The build process build is defined in the file \texttt{build.xml} in the
Mapyrus installation directory.  To build the software, documentation and zip
file for distribution, create a terminal window, change to the directory in
which Mapyrus is installed and execute the following command.

\begin{verbatim}
ant -v
\end{verbatim}

The build process also generates the PDF manual and manual examples in the
\texttt{userdoc} subdirectory from source files using \LaTeX.

All source code is in Java and contains javadoc style comments.  To view and
edit the source code, use a Java development environment such as Eclipse and
import the source code into a new project.

